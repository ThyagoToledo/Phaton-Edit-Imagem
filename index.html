<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phaton - Editor de Imagem Profissional</title>
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='45' fill='%234f46e5'/%3E%3Ctext x='50' y='60' font-family='Arial, sans-serif' font-size='40' font-weight='bold' text-anchor='middle' fill='white'%3EP%3C/text%3E%3C/svg%3E">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='45' fill='%234f46e5'/%3E%3Ctext x='50' y='60' font-family='Arial, sans-serif' font-size='40' font-weight='bold' text-anchor='middle' fill='white'%3EP%3C/text%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Vercel Speed Insights -->
    <script defer src="/_vercel/speed-insights/script.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .preview-bg {
            background-image:
                linear-gradient(45deg, #ddd 25%, transparent 25%),
                linear-gradient(-45deg, #ddd 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ddd 75%),
                linear-gradient(-45deg, transparent 75%, #ddd 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #3498db;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .cursor-wand {
             cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 3v4"/><path d="M19 17v4"/><path d="M3 5h4"/><path d="M17 19h4"/><path d="M12 3v18"/><path d="M3 12h18"/></svg>') 12 12, auto;
        }
        .tool-btn.active {
            background-color: #4f46e5;
            color: white;
        }
        #canvas-container {
            overflow: hidden; /* Crucial for zoom */
            position: relative;
        }
        #canvas {
            transition: transform 0.1s ease-out; /* Smooth pan */
            position: absolute;
            transform-origin: center center;
        }
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
        .cursor-crosshair { cursor: crosshair; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-5xl bg-white rounded-xl shadow-lg p-6 md:p-8">
        <div class="text-center mb-6">
            <h1 class="text-3xl font-bold text-gray-900">Phaton - Editor de Imagem</h1>
            <p class="text-gray-600 mt-2">Remova o fundo, retoque, finalize e defina a resolução da sua imagem.</p>
        </div>

        <!-- Controles -->
        <div class="flex flex-col gap-4 mb-6 p-4 bg-gray-50 rounded-lg">
            <div class="flex flex-wrap justify-center items-center gap-4">
                 <label for="upload" class="cursor-pointer bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors">Carregar Imagem</label>
                <input id="upload" type="file" class="hidden" accept="image/*">
                <button id="undoBtn" class="bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>Desfazer</button>
                <button id="resetBtn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>Recomeçar</button>
                <button id="downloadBtn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>Download</button>
            </div>
            <hr>
            <div class="flex flex-wrap justify-center items-center gap-2 md:gap-4">
                <div class="font-medium">Ferramenta:</div>
                <button id="aiToolBtn" class="tool-btn active bg-gray-200 font-semibold py-2 px-3 text-sm md:px-4" disabled>1. Remoção</button>
                <button id="wandToolBtn" class="tool-btn bg-gray-200 font-semibold py-2 px-3 text-sm md:px-4" disabled>2. Retoque</button>
                <button id="finalizeToolBtn" class="tool-btn bg-gray-200 font-semibold py-2 px-3 text-sm md:px-4" disabled>3. Finalização</button>
                <button id="resolutionToolBtn" class="tool-btn bg-gray-200 font-semibold py-2 px-3 text-sm md:px-4" disabled>4. Resolução</button>
            </div>
            <!-- Controles específicos da ferramenta -->
            <div id="ai-controls" class="text-center">
                 <button id="analyzeBtn" class="bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700 transition-colors" disabled>Clique no Fundo</button>
            </div>
            <div id="wand-controls" class="hidden items-center justify-center gap-2">
                 <label for="tolerance" class="text-sm font-medium">Tolerância da Varinha:</label>
                <input id="tolerance" type="range" min="0" max="255" value="20" class="w-40 cursor-pointer">
                <span id="toleranceValue" class="text-sm font-semibold w-8 text-center">20</span>
            </div>
            <div id="finalize-controls" class="hidden flex-col items-center gap-4">
                <div class="flex flex-wrap justify-center gap-4">
                    <button id="sharpenBtn" class="bg-sky-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-700 transition-colors" disabled>Melhorar Nitidez</button>
                    <button id="hdPolishBtn" class="bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-emerald-700 transition-colors" disabled>Polimento HD</button>
                    <button id="pixelateBtn" class="bg-gray-700 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-800 transition-colors" disabled>Transformar em Pixel Art</button>
                </div>
                <div class="w-full max-w-sm p-4 border rounded-lg mt-2">
                    <div class="grid grid-cols-2 gap-4 items-center">
                        <label for="brightness" class="text-sm font-medium justify-self-end">Brilho:</label>
                        <input id="brightness" type="range" min="-100" max="100" value="0" class="w-full">
                        <label for="contrast" class="text-sm font-medium justify-self-end">Contraste:</label>
                        <input id="contrast" type="range" min="-100" max="100" value="0" class="w-full">
                    </div>
                    <button id="applyBrightnessContrastBtn" class="mt-4 w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors" disabled>Aplicar Brilho e Contraste</button>
                </div>
            </div>
            <div id="resolution-controls" class="hidden flex-col items-center gap-4">
                <div class="flex flex-wrap justify-center items-center gap-2">
                    <button class="res-btn bg-gray-200 font-semibold py-1 px-3 rounded-lg" data-w="1920" data-h="1080">Full HD</button>
                    <button class="res-btn bg-gray-200 font-semibold py-1 px-3 rounded-lg" data-w="1280" data-h="720">HD</button>
                    <button class="res-btn bg-gray-200 font-semibold py-1 px-3 rounded-lg" data-w="1080" data-h="1080">Quadrado</button>
                </div>
                 <div class="flex items-center gap-2">
                    <input id="resW" type="number" placeholder="Width" class="w-24 p-2 border rounded-md">
                    <button id="aspectLock" class="p-2 rounded-md bg-indigo-200 text-indigo-700">
                        <svg id="lockIcon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-lock-fill" viewBox="0 0 16 16"><path d="M8 1a2 2 0 0 1 2 2v4H6V3a2 2 0 0 1 2-2zm3 6H5a1 1 0 0 0-1 1v3a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V8a1 1 0 0 0-1-1z"/></svg>
                        <svg id="unlockIcon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-unlock-fill hidden" viewBox="0 0 16 16"><path d="M11 1a2 2 0 0 0-2 2v4a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V3a3 3 0 0 1 6 0v4a.5.5 0 0 1-1 0V3a2 2 0 0 0-2-2z"/></svg>
                    </button>
                    <input id="resH" type="number" placeholder="Height" class="w-24 p-2 border rounded-md">
                </div>
                <div id="preview-container" class="w-full max-w-xs p-2 border rounded-lg bg-gray-100 hidden">
                    <p class="text-center font-semibold mb-2">Pré-visualização</p>
                    <canvas id="previewCanvas" class="w-full h-auto preview-bg"></canvas>
                </div>
                <button id="applyResolutionBtn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors" disabled>Aplicar Resolução</button>
            </div>
        </div>

        <!-- Canvas -->
        <div id="canvas-container" class="w-full h-96 md:h-[500px] bg-white rounded-lg overflow-hidden shadow-inner flex items-center justify-center preview-bg relative">
             <canvas id="canvas" class="absolute"></canvas>
             <div id="placeholder" class="text-gray-500 text-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mx-auto text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>
                <p class="mt-2">A sua imagem aparecerá aqui.</p>
            </div>
            <div id="loading-overlay" class="absolute inset-0 bg-white bg-opacity-75 flex-col items-center justify-center hidden">
                <div class="loader"></div><p id="loading-text" class="mt-4 text-gray-700 font-semibold">Processando...</p>
            </div>
        </div>
    </div>

    <script>
        // --- ELEMENTOS DO DOM ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const uploadInput = document.getElementById('upload');
        const downloadBtn = document.getElementById('downloadBtn');
        const resetBtn = document.getElementById('resetBtn');
        const undoBtn = document.getElementById('undoBtn');
        const placeholder = document.getElementById('placeholder');
        const canvasContainer = document.getElementById('canvas-container');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const aiToolBtn = document.getElementById('aiToolBtn'), wandToolBtn = document.getElementById('wandToolBtn'), finalizeToolBtn = document.getElementById('finalizeToolBtn'), resolutionToolBtn = document.getElementById('resolutionToolBtn');
        const aiControls = document.getElementById('ai-controls'), wandControls = document.getElementById('wand-controls'), finalizeControls = document.getElementById('finalize-controls'), resolutionControls = document.getElementById('resolution-controls');
        const analyzeBtn = document.getElementById('analyzeBtn'), toleranceInput = document.getElementById('tolerance'), toleranceValue = document.getElementById('toleranceValue');
        const sharpenBtn = document.getElementById('sharpenBtn'), hdPolishBtn = document.getElementById('hdPolishBtn'), pixelateBtn = document.getElementById('pixelateBtn'), brightnessInput = document.getElementById('brightness'), contrastInput = document.getElementById('contrast'), applyBrightnessContrastBtn = document.getElementById('applyBrightnessContrastBtn');
        const resWInput = document.getElementById('resW'), resHInput = document.getElementById('resH'), aspectLockBtn = document.getElementById('aspectLock'), lockIcon = document.getElementById('lockIcon'), unlockIcon = document.getElementById('unlockIcon');
        const previewContainer = document.getElementById('preview-container'), previewCanvas = document.getElementById('previewCanvas'), applyResolutionBtn = document.getElementById('applyResolutionBtn');

        // --- ESTADO DA APLICAÇÃO ---
        let originalImage = null, originalImageData = null, currentMode = 'ai', history = [], targetResolution = {w: 0, h: 0};
        let isAspectLocked = true;
        let zoom = { scale: 1, panX: 0, panY: 0, isPanning: false, startX: 0, startY: 0 };
        let baseCanvasSize = { width: 0, height: 0, left: 0, top: 0 };

        // --- INICIALIZAÇÃO E EVENTOS GERAIS ---
        uploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    setupCanvas(img);
                    enableControls();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        function setupCanvas(img) {
            const containerRect = canvasContainer.getBoundingClientRect();
            const containerWidth = containerRect.width - 20; // Margem para evitar overflow
            const containerHeight = containerRect.height - 20;
            
            const imgRatio = img.width / img.height;
            const containerRatio = containerWidth / containerHeight;
            
            // Determinar o tamanho de exibição do canvas
            let displayWidth, displayHeight;
            if (imgRatio > containerRatio) {
                displayWidth = containerWidth;
                displayHeight = containerWidth / imgRatio;
            } else {
                displayHeight = containerHeight;
                displayWidth = containerHeight * imgRatio;
            }
            
            // Definir o tamanho real do canvas (resolução)
            canvas.width = img.width;
            canvas.height = img.height;
            
            // Definir o tamanho de exibição via CSS
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            // Centralizar o canvas no container
            const offsetX = (containerRect.width - displayWidth) / 2;
            const offsetY = (containerRect.height - displayHeight) / 2;
            canvas.style.left = offsetX + 'px';
            canvas.style.top = offsetY + 'px';
            canvas.style.position = 'absolute';
            
            // Armazenar o tamanho base para cálculos de zoom
            baseCanvasSize = {
                width: displayWidth,
                height: displayHeight,
                left: offsetX,
                top: offsetY
            };
            
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            history = [];
            resetZoom();
            placeholder.style.display = 'none';
            canvas.style.display = 'block';
        }

        function enableControls() {
            [analyzeBtn, downloadBtn, resetBtn, aiToolBtn, wandToolBtn, finalizeToolBtn, resolutionToolBtn, sharpenBtn, hdPolishBtn, pixelateBtn, applyBrightnessContrastBtn, applyResolutionBtn].forEach(btn => btn.disabled = false);
            undoBtn.disabled = true;
        }

        // --- GESTÃO DE ESTADO (HISTÓRICO) ---
        function saveState() {
            history.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
            undoBtn.disabled = false;
        }

        undoBtn.addEventListener('click', () => {
            if (history.length > 0) {
                const lastState = history.pop();
                canvas.width = lastState.width;
                canvas.height = lastState.height;
                ctx.putImageData(lastState, 0, 0);
                resetZoom();
            }
            if (history.length === 0) {
                undoBtn.disabled = true;
            }
        });

        resetBtn.addEventListener('click', () => {
            if (originalImageData) {
                 setupCanvas(originalImage);
                 history = [];
                 undoBtn.disabled = true;
            }
        });

        // --- LÓGICA DE CONTROLO DAS FERRAMENTAS ---
        aiToolBtn.addEventListener('click', () => switchTool('ai'));
        wandToolBtn.addEventListener('click', () => switchTool('wand'));
        finalizeToolBtn.addEventListener('click', () => switchTool('finalize'));
        resolutionToolBtn.addEventListener('click', () => switchTool('resolution'));
        toleranceInput.addEventListener('input', (e) => { toleranceValue.textContent = e.target.value; });

        function switchTool(tool) {
            currentMode = tool;
            [aiToolBtn, wandToolBtn, finalizeToolBtn, resolutionToolBtn].forEach(btn => btn.classList.remove('active'));
            [aiControls, wandControls, finalizeControls, resolutionControls].forEach(p => p.style.display = 'none');
            
            // Limpar todas as classes de cursor
            canvas.classList.remove('cursor-wand', 'cursor-grab', 'cursor-grabbing', 'cursor-crosshair');
            canvasContainer.classList.remove('cursor-grab', 'cursor-grabbing');

            // Reset do botão AI se estava em modo click ou automático
            if (analyzeBtn.textContent === 'Automático' || analyzeBtn.textContent === 'Cancelar') {
                analyzeBtn.textContent = 'Clique no Fundo';
                analyzeBtn.style.backgroundColor = '';
                hideTooltip();
            }

            if (tool === 'ai') { 
                aiToolBtn.classList.add('active'); 
                aiControls.style.display = 'block'; 
            } 
            else if (tool === 'wand') { 
                wandToolBtn.classList.add('active'); 
                wandControls.style.display = 'flex'; 
                canvas.classList.add('cursor-wand');
                // Remover cursor de grab quando em modo wand
                canvasContainer.classList.remove('cursor-grab');
            }
            else if (tool === 'finalize') { 
                finalizeToolBtn.classList.add('active'); 
                finalizeControls.style.display = 'flex'; 
            }
            else if (tool === 'resolution') { 
                resolutionToolBtn.classList.add('active'); 
                resolutionControls.style.display = 'flex'; 
            }
            
            // Reaplica cursor de grab se necessário (exceto no modo wand)
            if (zoom.scale > 1 && tool !== 'wand') {
                canvasContainer.classList.add('cursor-grab');
            }
        }
        
        // --- LÓGICA DE ZOOM E PAN ---
        function resetZoom() {
            zoom = { scale: 1, panX: 0, panY: 0, isPanning: false, startX: 0, startY: 0 };
            updateCanvasTransform();
        }

        function updateCanvasTransform() {
            const transformX = baseCanvasSize.left + zoom.panX;
            const transformY = baseCanvasSize.top + zoom.panY;
            canvas.style.transform = `translate(${transformX}px, ${transformY}px) scale(${zoom.scale})`;
            canvas.style.transformOrigin = '0 0';
        }

        canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const containerRect = canvasContainer.getBoundingClientRect();
            
            // Coordenadas do mouse relativas ao container
            const mouseX = e.clientX - containerRect.left;
            const mouseY = e.clientY - containerRect.top;
            
            // Posição do mouse relativa ao canvas antes do zoom
            const beforeZoomX = (mouseX - baseCanvasSize.left - zoom.panX) / zoom.scale;
            const beforeZoomY = (mouseY - baseCanvasSize.top - zoom.panY) / zoom.scale;
            
            const scaleAmount = 1.15;
            const oldScale = zoom.scale;
            
            if (e.deltaY < 0) {
                zoom.scale = Math.min(zoom.scale * scaleAmount, 10);
            } else {
                zoom.scale = Math.max(zoom.scale / scaleAmount, 0.1);
            }
            
            // Ajustar pan para manter o ponto do mouse no mesmo lugar
            zoom.panX = mouseX - baseCanvasSize.left - (beforeZoomX * zoom.scale);
            zoom.panY = mouseY - baseCanvasSize.top - (beforeZoomY * zoom.scale);

            updateCanvasTransform();
            
            // Atualizar cursor baseado no zoom
            if (zoom.scale > 1 && currentMode !== 'wand') {
                canvasContainer.classList.add('cursor-grab');
            } else {
                canvasContainer.classList.remove('cursor-grab');
            }
        });

        canvasContainer.addEventListener('mousedown', (e) => {
            if (zoom.scale > 1 && currentMode !== 'wand') {
                zoom.isPanning = true;
                const containerRect = canvasContainer.getBoundingClientRect();
                zoom.startX = e.clientX - containerRect.left - zoom.panX;
                zoom.startY = e.clientY - containerRect.top - zoom.panY;
                canvasContainer.classList.add('cursor-grabbing');
                e.preventDefault();
            }
        });

        window.addEventListener('mouseup', (e) => {
            if (zoom.isPanning) {
                zoom.lastPanTime = Date.now();
            }
            zoom.isPanning = false;
            canvasContainer.classList.remove('cursor-grabbing');
        });

        window.addEventListener('mousemove', (e) => {
            if (zoom.isPanning) {
                const containerRect = canvasContainer.getBoundingClientRect();
                zoom.panX = e.clientX - containerRect.left - zoom.startX;
                zoom.panY = e.clientY - containerRect.top - zoom.startY;
                updateCanvasTransform();
                e.preventDefault();
            }
        });

        function getTransformedMouseCoords(e) {
            const canvasRect = canvas.getBoundingClientRect();
            const containerRect = canvasContainer.getBoundingClientRect();
            
            // Coordenadas do mouse relativas ao canvas visível
            const mouseX = e.clientX - canvasRect.left;
            const mouseY = e.clientY - canvasRect.top;
            
            // Calcular a escala entre canvas real e canvas exibido
            const displayScaleX = canvas.width / canvasRect.width;
            const displayScaleY = canvas.height / canvasRect.height;
            
            // Converter para coordenadas do canvas real
            const realX = mouseX * displayScaleX;
            const realY = mouseY * displayScaleY;
            
            return {
                x: Math.max(0, Math.min(Math.floor(realX), canvas.width - 1)),
                y: Math.max(0, Math.min(Math.floor(realY), canvas.height - 1))
            };
        }

        // --- LÓGICA DAS FERRAMENTAS ---
        analyzeBtn.addEventListener('click', () => {
            if (!originalImageData) return;
            
            // Alternar entre modo normal, modo click e modo automático
            if (analyzeBtn.textContent === 'Clique no Fundo') {
                // Ativar modo click
                analyzeBtn.textContent = 'Automático';
                analyzeBtn.style.backgroundColor = '#3b82f6';
                showTooltip('Clique na área do fundo que deseja remover');
                currentMode = 'ai-click';
                canvas.classList.add('cursor-crosshair');
            } else if (analyzeBtn.textContent === 'Automático') {
                // Ativar modo automático
                analyzeBtn.textContent = 'Cancelar';
                analyzeBtn.style.backgroundColor = '#ef4444';
                showTooltip('Executando remoção automática de fundo...');
                currentMode = 'ai-auto';
                canvas.classList.remove('cursor-crosshair');
                
                // Executar remoção automática após um breve delay
                setTimeout(() => {
                    automaticBackgroundRemoval();
                    // Voltar ao estado inicial
                    analyzeBtn.textContent = 'Clique no Fundo';
                    analyzeBtn.style.backgroundColor = '';
                    currentMode = 'ai';
                    hideTooltip();
                }, 100);
            } else {
                // Cancelar qualquer modo - voltar ao estado inicial
                analyzeBtn.textContent = 'Clique no Fundo';
                analyzeBtn.style.backgroundColor = '';
                currentMode = 'ai';
                canvas.classList.remove('cursor-crosshair');
                hideTooltip();
            }
        });

        canvasContainer.addEventListener('click', (e) => {
            if (!originalImageData || zoom.isPanning) return;
            
            // Prevenir clique durante o panning
            if (Date.now() - (zoom.lastPanTime || 0) < 100) return;
            
            // Verificar se o clique foi realmente no canvas
            const canvasRect = canvas.getBoundingClientRect();
            const clickX = e.clientX;
            const clickY = e.clientY;
            
            if (clickX < canvasRect.left || clickX > canvasRect.right || 
                clickY < canvasRect.top || clickY > canvasRect.bottom) {
                return; // Clique fora do canvas
            }
            
            const coords = getTransformedMouseCoords(e);
            
            // Verificar se as coordenadas estão dentro dos limites do canvas
            if (coords.x < 0 || coords.x >= canvas.width || coords.y < 0 || coords.y >= canvas.height) {
                return;
            }
            
            if (currentMode === 'wand') {
                saveState();
                const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                floodFill(currentImageData, coords.x, coords.y, parseInt(toleranceInput.value, 10));
                ctx.putImageData(currentImageData, 0, 0);
            } else if (currentMode === 'ai-click') {
                // Modo AI Click - analisar e remover cor específica
                saveState();
                intelligentColorRemoval(coords.x, coords.y);
                
                // Voltar ao modo normal
                analyzeBtn.textContent = 'Clique no Fundo';
                analyzeBtn.style.backgroundColor = '';
                currentMode = 'ai';
                canvas.classList.remove('cursor-crosshair');
                hideTooltip();
            }
        });

        sharpenBtn.addEventListener('click', () => applyConvolution(getSharpenKernel()));
        hdPolishBtn.addEventListener('click', applyBilateralFilter);
        pixelateBtn.addEventListener('click', applyPixelation);
        applyBrightnessContrastBtn.addEventListener('click', applyBrightnessContrast);
        
        document.querySelectorAll('.res-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                resWInput.value = e.currentTarget.dataset.w;
                resHInput.value = e.currentTarget.dataset.h;
                updateResolutionPreview();
            });
        });

        resWInput.addEventListener('input', () => {
            if(isAspectLocked) {
                const ratio = canvas.height / canvas.width;
                resHInput.value = Math.round(resWInput.value * ratio);
            }
            updateResolutionPreview();
        });
        resHInput.addEventListener('input', () => {
            if(isAspectLocked) {
                const ratio = canvas.width / canvas.height;
                resWInput.value = Math.round(resHInput.value * ratio);
            }
            updateResolutionPreview();
        });
        aspectLockBtn.addEventListener('click', () => {
            isAspectLocked = !isAspectLocked;
            lockIcon.classList.toggle('hidden', !isAspectLocked);
            unlockIcon.classList.toggle('hidden', isAspectLocked);
            aspectLockBtn.classList.toggle('bg-indigo-200', isAspectLocked);
            aspectLockBtn.classList.toggle('bg-gray-200', !isAspectLocked);
        });

        applyResolutionBtn.addEventListener('click', applyResolution);

        // --- FUNÇÕES DE PROCESSAMENTO DE IMAGEM ---

        function updateResolutionPreview() {
            if (!originalImageData || !resWInput.value || !resHInput.value) return;
            
            targetResolution = { w: parseInt(resWInput.value), h: parseInt(resHInput.value) };
            
            previewContainer.style.display = 'block';
            const previewCtx = previewCanvas.getContext('2d');
            previewCanvas.width = targetResolution.w;
            previewCanvas.height = targetResolution.h;
            previewCtx.drawImage(canvas, 0, 0, targetResolution.w, targetResolution.h);
        }
        
        function applyResolution() {
            if (!targetResolution.w || !originalImageData) return;
            saveState();
            showLoading(true, 'Redimensionando...');
            setTimeout(() => {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = targetResolution.w;
                tempCanvas.height = targetResolution.h;
                
                // Melhor qualidade de redimensionamento
                tempCtx.imageSmoothingEnabled = true;
                tempCtx.imageSmoothingQuality = 'high';
                tempCtx.drawImage(canvas, 0, 0, targetResolution.w, targetResolution.h);

                canvas.width = targetResolution.w;
                canvas.height = targetResolution.h;
                
                // Reconfigurar o canvas com as novas dimensões
                const img = new Image();
                img.onload = () => {
                    setupCanvas(img);
                    showLoading(false);
                };
                img.src = tempCanvas.toDataURL();
            }, 50);
        }

        function applyPixelation() {
            if (!originalImageData) return;
            saveState();
            showLoading(true, 'Criando pixel art...');
            setTimeout(() => {
                const size = 256;
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = size; tempCanvas.height = size;
                tempCtx.drawImage(canvas, 0, 0, size, size);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
                ctx.imageSmoothingEnabled = true;
                showLoading(false);
            }, 50);
        }

        function applyConvolution(kernel) {
            if (!originalImageData) return;
            saveState();
            showLoading(true, 'Aplicando filtro...');
            setTimeout(() => {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const { data, width, height } = imageData;
                const outputData = new Uint8ClampedArray(data);
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const i = (y * width + x) * 4;
                        if (data[i + 3] === 0) continue;
                        let r = 0, g = 0, b = 0;
                        for (let ky = 0; ky < 3; ky++) {
                            for (let kx = 0; kx < 3; kx++) {
                                const pixelIndex = ((y + ky - 1) * width + (x + kx - 1)) * 4;
                                r += data[pixelIndex] * kernel[ky][kx];
                                g += data[pixelIndex + 1] * kernel[ky][kx];
                                b += data[pixelIndex + 2] * kernel[ky][kx];
                            }
                        }
                        outputData[i] = r; outputData[i + 1] = g; outputData[i + 2] = b;
                    }
                }
                ctx.putImageData(new ImageData(outputData, width, height), 0, 0);
                showLoading(false);
            }, 50);
        }
        
        function applyBilateralFilter() {
            if (!originalImageData) return;
            saveState();
            showLoading(true, 'Aplicando Polimento HD...');
            setTimeout(() => {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const { data, width, height } = imageData;
                const outputData = new Uint8ClampedArray(data);
                const sigmaSpace = 3, sigmaColor = 50;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        if (data[i + 3] === 0) continue;
                        let r_sum = 0, g_sum = 0, b_sum = 0, weight_sum = 0;
                        const r_c = data[i], g_c = data[i+1], b_c = data[i+2];
                        for (let ky = -sigmaSpace; ky <= sigmaSpace; ky++) {
                            for (let kx = -sigmaSpace; kx <= sigmaSpace; kx++) {
                                const ny = y + ky, nx = x + kx;
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const ni = (ny * width + nx) * 4;
                                    if (data[ni + 3] === 0) continue;
                                    const r_n = data[ni], g_n = data[ni+1], b_n = data[ni+2];
                                    const spaceDist = -(kx*kx + ky*ky) / (2 * sigmaSpace * sigmaSpace);
                                    const colorDist = -(Math.pow(r_c - r_n, 2) + Math.pow(g_c - g_n, 2) + Math.pow(b_c - b_n, 2)) / (2 * sigmaColor * sigmaColor);
                                    const weight = Math.exp(spaceDist + colorDist);
                                    r_sum += r_n * weight; g_sum += g_n * weight; b_sum += b_n * weight; weight_sum += weight;
                                }
                            }
                        }
                        outputData[i] = r_sum / weight_sum; outputData[i+1] = g_sum / weight_sum; outputData[i+2] = b_sum / weight_sum;
                    }
                }
                ctx.putImageData(new ImageData(outputData, width, height), 0, 0);
                showLoading(false);
            }, 50);
        }
        
        function applyBrightnessContrast() {
            if (!originalImageData) return;
            saveState();
            showLoading(true, 'Aplicando ajustes...');
            setTimeout(() => {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const brightness = parseInt(brightnessInput.value), contrast = parseInt(contrastInput.value);
                const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] === 0) continue;
                    data[i] = factor * (data[i] + brightness - 128) + 128;
                    data[i + 1] = factor * (data[i + 1] + brightness - 128) + 128;
                    data[i + 2] = factor * (data[i + 2] + brightness - 128) + 128;
                }
                ctx.putImageData(imageData, 0, 0);
                showLoading(false);
            }, 50);
        }

        function getSharpenKernel() { return [[0, -1, 0], [-1, 5, -1], [0, -1, 0]]; }

        function intelligentColorRemoval(clickX, clickY) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const { data, width, height } = imageData;
            
            // Obter a cor clicada
            const clickIndex = (clickY * width + clickX) * 4;
            const targetColor = [data[clickIndex], data[clickIndex + 1], data[clickIndex + 2]];
            
            // Remover TODA a cor da imagem (não apenas área conectada)
            removeColorGlobally(imageData, targetColor);
            
            ctx.putImageData(imageData, 0, 0);
        }

        function automaticBackgroundRemoval() {
            if (!originalImageData) return;
            
            saveState();
            showLoading(true, 'Removendo fundo automaticamente...');
            
            setTimeout(() => {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const { data, width, height } = imageData;
                
                // Detectar cores de fundo automaticamente
                const backgroundColors = detectBackgroundColors(imageData);
                
                if (backgroundColors.length === 0) {
                    showLoading(false);
                    showTooltip('Nenhuma cor de fundo detectada automaticamente');
                    setTimeout(hideTooltip, 2000);
                    return;
                }
                
                // Aplicar remoção inteligente para cada cor de fundo detectada
                for (const bgColor of backgroundColors) {
                    intelligentColorRemovalByColor(imageData, bgColor);
                }
                
                // Aplicar refinamento das bordas
                refineTransparencyEdges(imageData);
                
                ctx.putImageData(imageData, 0, 0);
                showLoading(false);
                
                showTooltip(`Fundo removido automaticamente! ${backgroundColors.length} cor(es) de fundo detectada(s)`);
                setTimeout(hideTooltip, 3000);
            }, 50);
        }

        function detectBackgroundColors(imageData) {
            const { data, width, height } = imageData;
            const colorMap = new Map();
            const sampleSize = 2; // Amostragem mais esparsa para performance
            
            // Coletar cores das bordas da imagem (mais provável serem fundo)
            const edgePixels = [];
            
            // Bordas superiores e inferiores
            for (let x = 0; x < width; x += sampleSize) {
                edgePixels.push(getPixelColor(data, width, x, 0));
                edgePixels.push(getPixelColor(data, width, x, height - 1));
            }
            
            // Bordas esquerdas e direitas
            for (let y = 0; y < height; y += sampleSize) {
                edgePixels.push(getPixelColor(data, width, 0, y));
                edgePixels.push(getPixelColor(data, width, width - 1, y));
            }
            
            // Contar frequência das cores
            edgePixels.forEach(color => {
                if (color[3] > 0) { // Ignorar pixels transparentes
                    const colorKey = `${color[0]},${color[1]},${color[2]}`;
                    colorMap.set(colorKey, (colorMap.get(colorKey) || 0) + 1);
                }
            });
            
            // Agrupar cores similares e encontrar as mais frequentes
            const colorGroups = [];
            for (const [colorKey, count] of colorMap.entries()) {
                const color = colorKey.split(',').map(Number);
                let addedToGroup = false;
                
                for (const group of colorGroups) {
                    if (colorDistance(color, group.color) < 30) {
                        group.count += count;
                        // Atualizar cor média do grupo
                        group.color[0] = Math.round((group.color[0] + color[0]) / 2);
                        group.color[1] = Math.round((group.color[1] + color[1]) / 2);
                        group.color[2] = Math.round((group.color[2] + color[2]) / 2);
                        addedToGroup = true;
                        break;
                    }
                }
                
                if (!addedToGroup) {
                    colorGroups.push({ color, count });
                }
            }
            
            // Ordenar por frequência e retornar as mais comuns
            colorGroups.sort((a, b) => b.count - a.count);
            
            // Retornar até 3 cores de fundo mais prováveis
            return colorGroups.slice(0, 3).map(group => group.color);
        }

        function getPixelColor(data, width, x, y) {
            const index = (y * width + x) * 4;
            return [data[index], data[index + 1], data[index + 2], data[index + 3]];
        }

        function intelligentColorRemovalByColor(imageData, targetColor) {
            const { data, width, height } = imageData;
            const tolerance = calculateDynamicTolerance(targetColor);
            
            // Usar flood fill a partir das bordas para essa cor específica
            const processed = new Set();
            
            // Iniciar flood fill das bordas
            for (let x = 0; x < width; x++) {
                // Borda superior
                if (!processed.has(`${x},0`)) {
                    const topColor = [data[x * 4], data[x * 4 + 1], data[x * 4 + 2]];
                    if (colorDistance(targetColor, topColor) <= tolerance) {
                        intelligentFloodFillFromPoint(imageData, x, 0, targetColor, processed);
                    }
                }
                
                // Borda inferior
                const bottomIndex = ((height - 1) * width + x) * 4;
                if (!processed.has(`${x},${height - 1}`)) {
                    const bottomColor = [data[bottomIndex], data[bottomIndex + 1], data[bottomIndex + 2]];
                    if (colorDistance(targetColor, bottomColor) <= tolerance) {
                        intelligentFloodFillFromPoint(imageData, x, height - 1, targetColor, processed);
                    }
                }
            }
            
            for (let y = 0; y < height; y++) {
                // Borda esquerda
                const leftIndex = (y * width) * 4;
                if (!processed.has(`0,${y}`)) {
                    const leftColor = [data[leftIndex], data[leftIndex + 1], data[leftIndex + 2]];
                    if (colorDistance(targetColor, leftColor) <= tolerance) {
                        intelligentFloodFillFromPoint(imageData, 0, y, targetColor, processed);
                    }
                }
                
                // Borda direita
                const rightIndex = (y * width + (width - 1)) * 4;
                if (!processed.has(`${width - 1},${y}`)) {
                    const rightColor = [data[rightIndex], data[rightIndex + 1], data[rightIndex + 2]];
                    if (colorDistance(targetColor, rightColor) <= tolerance) {
                        intelligentFloodFillFromPoint(imageData, width - 1, y, targetColor, processed);
                    }
                }
            }
        }

        function intelligentFloodFillFromPoint(imageData, startX, startY, targetColor, processed) {
            const { data, width, height } = imageData;
            const stack = [[startX, startY]];
            const tolerance = calculateDynamicTolerance(targetColor);
            
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;
                
                if (processed.has(key) || x < 0 || x >= width || y < 0 || y >= height) continue;
                processed.add(key);
                
                const pixelIndex = (y * width + x) * 4;
                const currentColor = [data[pixelIndex], data[pixelIndex + 1], data[pixelIndex + 2]];
                
                if (colorDistance(targetColor, currentColor) <= tolerance && data[pixelIndex + 3] > 0) {
                    const shouldProtect = shouldProtectPixel(imageData, x, y, targetColor);
                    
                    if (!shouldProtect) {
                        const colorDist = colorDistance(targetColor, currentColor);
                        const alpha = Math.max(0, 1 - (colorDist / tolerance));
                        data[pixelIndex + 3] *= (1 - alpha * 0.85);
                        
                        // Adicionar vizinhos à pilha
                        stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
                    }
                }
            }
        }

        function refineTransparencyEdges(imageData) {
            const { data, width, height } = imageData;
            const newData = new Uint8ClampedArray(data);
            
            // Suavizar bordas entre áreas transparentes e opacas
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const centerIndex = (y * width + x) * 4;
                    const centerAlpha = data[centerIndex + 3];
                    
                    // Se o pixel está parcialmente transparente, analisar vizinhança
                    if (centerAlpha > 0 && centerAlpha < 255) {
                        let totalAlpha = 0;
                        let solidNeighbors = 0;
                        
                        // Verificar vizinhos 3x3
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const neighborIndex = (ny * width + nx) * 4;
                                    const neighborAlpha = data[neighborIndex + 3];
                                    
                                    if (neighborAlpha > 128) {
                                        solidNeighbors++;
                                        totalAlpha += neighborAlpha;
                                    }
                                }
                            }
                        }
                        
                        // Se a maioria dos vizinhos são sólidos, aumentar opacidade
                        if (solidNeighbors >= 5) {
                            const avgAlpha = totalAlpha / solidNeighbors;
                            newData[centerIndex + 3] = Math.min(255, (centerAlpha + avgAlpha) / 2);
                        }
                    }
                }
            }
            
            // Aplicar os dados refinados
            for (let i = 0; i < data.length; i++) {
                data[i] = newData[i];
            }
        }

        function removeColorGlobally(imageData, targetColor) {
            const { data, width, height } = imageData;
            const tolerance = calculateDynamicTolerance(targetColor);
            
            // Percorrer TODOS os pixels da imagem
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const pixelIndex = (y * width + x) * 4;
                    
                    // Pular pixels já transparentes
                    if (data[pixelIndex + 3] === 0) continue;
                    
                    const currentColor = [data[pixelIndex], data[pixelIndex + 1], data[pixelIndex + 2]];
                    
                    // Verificar se a cor é similar ao alvo
                    if (colorDistance(targetColor, currentColor) <= tolerance) {
                        // Verificar se deve proteger o pixel (análise local de contexto)
                        const shouldProtect = shouldProtectPixel(imageData, x, y, targetColor);
                        
                        if (!shouldProtect) {
                            // Aplicar transparência gradual baseada na distância da cor
                            const colorDist = colorDistance(targetColor, currentColor);
                            const alpha = Math.max(0, 1 - (colorDist / tolerance));
                            data[pixelIndex + 3] *= (1 - alpha * 0.9); // Remove até 90% da opacidade
                        }
                    }
                }
            }
        }

        function calculateDynamicTolerance(color) {
            // Calcular saturação da cor
            const r = color[0] / 255;
            const g = color[1] / 255;
            const b = color[2] / 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const saturation = max === 0 ? 0 : (max - min) / max;
            
            // Calcular luminância
            const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
            
            // Tolerância baseada nas características da cor
            let tolerance = 30; // Valor base
            
            // Cores mais saturadas = menor tolerância (mais precisão)
            if (saturation > 0.5) {
                tolerance *= 0.7;
            } else if (saturation < 0.2) {
                tolerance *= 1.3; // Cores dessaturadas = maior tolerância
            }
            
            // Cores muito claras ou escuras = maior tolerância
            if (luminance > 0.8 || luminance < 0.2) {
                tolerance *= 1.2;
            }
            
            return Math.min(Math.max(tolerance, 15), 60); // Limitar entre 15 e 60
        }

        function shouldProtectPixel(imageData, x, y, targetColor) {
            const { data, width, height } = imageData;
            const radius = 3;
            let differentColorCount = 0;
            let totalSamples = 0;
            
            // Analisar vizinhança para detectar se o pixel está em uma área de detalhes
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        const neighborIndex = (ny * width + nx) * 4;
                        if (data[neighborIndex + 3] > 0) { // Pixel não transparente
                            const neighborColor = [data[neighborIndex], data[neighborIndex + 1], data[neighborIndex + 2]];
                            
                            // Se a cor do vizinho é muito diferente da cor alvo
                            if (colorDistance(targetColor, neighborColor) > 50) {
                                differentColorCount++;
                            }
                            totalSamples++;
                        }
                    }
                }
            }
            
            // Se mais de 40% dos vizinhos têm cores diferentes, proteger o pixel
            return totalSamples > 0 && (differentColorCount / totalSamples) > 0.4;
        }

        function colorDistance(c1, c2) { 
            return Math.sqrt(Math.pow(c1[0] - c2[0], 2) + Math.pow(c1[1] - c2[1], 2) + Math.pow(c1[2] - c2[2], 2)); 
        }

        function floodFill(imageData, startX, startY, tolerance) {
            const { data, width, height } = imageData;
            const startIndex = (startY * width + startX) * 4;
            const targetColor = [data[startIndex], data[startIndex + 1], data[startIndex + 2]];
            
            const stack = [[startX, startY]];
            const visited = new Set();
            
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                
                if (x < 0 || x >= width || y < 0 || y >= height) continue;
                
                const key = `${x},${y}`;
                if (visited.has(key)) continue;
                visited.add(key);
                
                const currentNode = (y * width + x) * 4;
                const currentColor = [data[currentNode], data[currentNode + 1], data[currentNode + 2]];
                
                if (colorDistance(targetColor, currentColor) <= tolerance && data[currentNode + 3] > 0) {
                    data[currentNode + 3] = 0; // Tornar transparente
                    
                    // Adicionar vizinhos
                    stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
                }
            }
        }

        function showTooltip(text) {
            let tooltip = document.getElementById('ai-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'ai-tooltip';
                tooltip.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    font-size: 14px;
                    z-index: 1000;
                    pointer-events: none;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                `;
                document.body.appendChild(tooltip);
            }
            tooltip.textContent = text;
            tooltip.style.display = 'block';
        }
        
        function hideTooltip() {
            const tooltip = document.getElementById('ai-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }

        function showLoading(show, text = 'Processando...') {
            if (show) {
                loadingText.textContent = text;
                loadingOverlay.style.display = 'flex';
            } else {
                loadingOverlay.style.display = 'none';
            }
        }

        function downloadImage() {
            // Mostrar prompt para o usuário escolher o nome do arquivo
            let fileName = prompt('Digite o nome para o arquivo (sem extensão):', 'imagem_editada');
            
            // Se o usuário cancelou ou não digitou nada, usar nome padrão
            if (!fileName || fileName.trim() === '') {
                fileName = 'imagem_editada';
            }
            
            // Limpar caracteres inválidos do nome do arquivo
            fileName = fileName.replace(/[<>:"/\\|?*]/g, '_');
            
            // Criar link de download
            const link = document.createElement('a');
            link.download = fileName + '.png';
            link.href = canvas.toDataURL('image/png');
            
            // Simular clique para iniciar download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        downloadBtn.addEventListener('click', downloadImage);

    </script>
</body>
</html>
