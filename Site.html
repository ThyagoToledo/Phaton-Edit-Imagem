<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Imagem com Polimento HD (Filtro Bilateral)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .preview-bg {
            background-image:
                linear-gradient(45deg, #ddd 25%, transparent 25%),
                linear-gradient(-45deg, #ddd 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ddd 75%),
                linear-gradient(-45deg, transparent 75%, #ddd 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #3498db;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .cursor-wand {
             cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 3v4"/><path d="M19 17v4"/><path d="M3 5h4"/><path d="M17 19h4"/><path d="M12 3v18"/><path d="M3 12h18"/></svg>') 12 12, auto;
        }
        .tool-btn.active {
            background-color: #4f46e5;
            color: white;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl bg-white rounded-xl shadow-lg p-6 md:p-8">
        <div class="text-center mb-6">
            <h1 class="text-3xl font-bold text-gray-900">Editor de Imagem Profissional</h1>
            <p class="text-gray-600 mt-2">Remova o fundo, retoque, e finalize com melhorias de qualidade.</p>
        </div>

        <!-- Controles -->
        <div class="flex flex-col gap-4 mb-6 p-4 bg-gray-50 rounded-lg">
            <div class="flex flex-wrap justify-center items-center gap-4">
                 <label for="upload" class="cursor-pointer bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors">Carregar Imagem</label>
                <input id="upload" type="file" class="hidden" accept="image/*">
                <button id="undoBtn" class="bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>Desfazer</button>
                <button id="resetBtn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>Recomeçar</button>
                <button id="downloadBtn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>Download</button>
            </div>
            <hr>
            <div class="flex flex-wrap justify-center items-center gap-4">
                <div class="font-medium">Ferramenta:</div>
                <button id="aiToolBtn" class="tool-btn active bg-gray-200 font-semibold py-2 px-4 rounded-lg" disabled>1. Remoção Automática</button>
                <button id="wandToolBtn" class="tool-btn bg-gray-200 font-semibold py-2 px-4 rounded-lg" disabled>2. Retoque (Varinha)</button>
                <button id="finalizeToolBtn" class="tool-btn bg-gray-200 font-semibold py-2 px-4 rounded-lg" disabled>3. Finalização</button>
            </div>
            <!-- Controles específicos da ferramenta -->
            <div id="ai-controls" class="text-center">
                 <button id="analyzeBtn" class="bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700 transition-colors" disabled>Remover Fundo e Polir</button>
            </div>
            <div id="wand-controls" class="hidden items-center justify-center gap-2">
                 <label for="tolerance" class="text-sm font-medium">Tolerância da Varinha:</label>
                <input id="tolerance" type="range" min="0" max="255" value="20" class="w-40 cursor-pointer">
                <span id="toleranceValue" class="text-sm font-semibold w-8 text-center">20</span>
            </div>
            <div id="finalize-controls" class="hidden flex flex-col items-center gap-4">
                <div class="flex flex-wrap justify-center gap-4">
                    <button id="sharpenBtn" class="bg-sky-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-700 transition-colors" disabled>Melhorar Nitidez</button>
                    <button id="smoothBtn" class="bg-orange-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-600 transition-colors" disabled>Reduzir Ruído (Suave)</button>
                    <button id="hdPolishBtn" class="bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-emerald-700 transition-colors" disabled>Polimento HD</button>
                </div>
                <div class="w-full max-w-sm p-4 border rounded-lg mt-2">
                    <div class="grid grid-cols-2 gap-4 items-center">
                        <label for="brightness" class="text-sm font-medium justify-self-end">Brilho:</label>
                        <input id="brightness" type="range" min="-100" max="100" value="0" class="w-full">
                        <label for="contrast" class="text-sm font-medium justify-self-end">Contraste:</label>
                        <input id="contrast" type="range" min="-100" max="100" value="0" class="w-full">
                    </div>
                    <button id="applyBrightnessContrastBtn" class="mt-4 w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors" disabled>Aplicar Brilho e Contraste</button>
                </div>
            </div>
        </div>

        <!-- Canvas -->
        <div id="canvas-container" class="w-full h-96 md:h-[500px] bg-white rounded-lg overflow-hidden shadow-inner flex items-center justify-center preview-bg relative">
             <canvas id="canvas" class="hidden"></canvas>
             <div id="placeholder" class="text-gray-500 text-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mx-auto text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>
                <p class="mt-2">A sua imagem aparecerá aqui.</p>
            </div>
            <div id="loading-overlay" class="absolute inset-0 bg-white bg-opacity-75 flex-col items-center justify-center hidden">
                <div class="loader"></div><p id="loading-text" class="mt-4 text-gray-700 font-semibold">Processando...</p>
            </div>
        </div>
    </div>

    <script>
        // --- ELEMENTOS DO DOM ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const uploadInput = document.getElementById('upload');
        const downloadBtn = document.getElementById('downloadBtn');
        const resetBtn = document.getElementById('resetBtn');
        const undoBtn = document.getElementById('undoBtn');
        const placeholder = document.getElementById('placeholder');
        const canvasContainer = document.getElementById('canvas-container');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const aiToolBtn = document.getElementById('aiToolBtn'), wandToolBtn = document.getElementById('wandToolBtn'), finalizeToolBtn = document.getElementById('finalizeToolBtn');
        const aiControls = document.getElementById('ai-controls'), wandControls = document.getElementById('wand-controls'), finalizeControls = document.getElementById('finalize-controls');
        const analyzeBtn = document.getElementById('analyzeBtn'), toleranceInput = document.getElementById('tolerance'), toleranceValue = document.getElementById('toleranceValue');
        const sharpenBtn = document.getElementById('sharpenBtn'), smoothBtn = document.getElementById('smoothBtn'), hdPolishBtn = document.getElementById('hdPolishBtn'), brightnessInput = document.getElementById('brightness'), contrastInput = document.getElementById('contrast'), applyBrightnessContrastBtn = document.getElementById('applyBrightnessContrastBtn');

        // --- ESTADO DA APLICAÇÃO ---
        let originalImage = null, originalImageData = null, currentMode = 'ai', history = [];

        // --- INICIALIZAÇÃO E EVENTOS GERAIS ---
        uploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    setupCanvas(img);
                    enableControls();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        function setupCanvas(img) {
            const containerRatio = canvasContainer.clientWidth / canvasContainer.clientHeight;
            const imgRatio = img.width / img.height;
            canvas.width = (imgRatio > containerRatio) ? canvasContainer.clientWidth : canvasContainer.clientHeight * imgRatio;
            canvas.height = (imgRatio > containerRatio) ? canvasContainer.clientWidth / imgRatio : canvasContainer.clientHeight;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            history = [];
            placeholder.classList.add('hidden');
            canvas.classList.remove('hidden');
        }

        function enableControls() {
            [analyzeBtn, downloadBtn, resetBtn, aiToolBtn, wandToolBtn, finalizeToolBtn, sharpenBtn, smoothBtn, hdPolishBtn, applyBrightnessContrastBtn].forEach(btn => btn.disabled = false);
            undoBtn.disabled = true;
        }

        // --- GESTÃO DE ESTADO (HISTÓRICO) ---
        function saveState() {
            history.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
            undoBtn.disabled = false;
        }

        undoBtn.addEventListener('click', () => {
            if (history.length > 0) {
                const lastState = history.pop();
                ctx.putImageData(lastState, 0, 0);
            }
            if (history.length === 0) {
                undoBtn.disabled = true;
            }
        });

        resetBtn.addEventListener('click', () => {
            if (originalImageData) {
                 ctx.putImageData(originalImageData, 0, 0);
                 history = [];
                 undoBtn.disabled = true;
            }
        });

        // --- LÓGICA DE CONTROLO DAS FERRAMENTAS ---
        aiToolBtn.addEventListener('click', () => switchTool('ai'));
        wandToolBtn.addEventListener('click', () => switchTool('wand'));
        finalizeToolBtn.addEventListener('click', () => switchTool('finalize'));
        toleranceInput.addEventListener('input', (e) => { toleranceValue.textContent = e.target.value; });

        function switchTool(tool) {
            currentMode = tool;
            [aiToolBtn, wandToolBtn, finalizeToolBtn].forEach(btn => btn.classList.remove('active'));
            [aiControls, wandControls, finalizeControls].forEach(p => p.style.display = 'none');
            canvas.className = 'hidden';
            canvas.classList.remove('hidden');

            if (tool === 'ai') { aiToolBtn.classList.add('active'); aiControls.style.display = 'block'; } 
            else if (tool === 'wand') { wandToolBtn.classList.add('active'); wandControls.style.display = 'flex'; canvas.classList.add('cursor-wand'); }
            else if (tool === 'finalize') { finalizeToolBtn.classList.add('active'); finalizeControls.style.display = 'flex'; }
        }
        
        // --- LÓGICA DAS FERRAMENTAS ---
        analyzeBtn.addEventListener('click', () => {
            if (!originalImageData) return;
            saveState();
            showLoading(true, 'Removendo fundo...');
            setTimeout(() => {
                analyzeAndRemoveBackground();
                showLoading(true, 'Polindo bordas...');
                setTimeout(() => {
                    polishEdges();
                    showLoading(false);
                }, 50);
            }, 50);
        });

        canvas.addEventListener('click', (e) => {
            if (currentMode !== 'wand' || !originalImageData) return;
            saveState();
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor(e.clientX - rect.left), y = Math.floor(e.clientY - rect.top);
            const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            floodFill(currentImageData, x, y, parseInt(toleranceInput.value, 10));
            ctx.putImageData(currentImageData, 0, 0);
        });

        sharpenBtn.addEventListener('click', () => applyConvolution(getSharpenKernel()));
        smoothBtn.addEventListener('click', () => applyConvolution(getSmoothKernel()));
        hdPolishBtn.addEventListener('click', applyBilateralFilter);
        applyBrightnessContrastBtn.addEventListener('click', applyBrightnessContrast);

        // --- FUNÇÕES DE PROCESSAMENTO DE IMAGEM ---
        function applyConvolution(kernel) {
            if (!originalImageData) return;
            saveState();
            showLoading(true, 'Aplicando filtro...');
            setTimeout(() => {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const { data, width, height } = imageData;
                const outputData = new Uint8ClampedArray(data);
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const i = (y * width + x) * 4;
                        if (data[i + 3] === 0) continue;
                        let r = 0, g = 0, b = 0;
                        for (let ky = 0; ky < 3; ky++) {
                            for (let kx = 0; kx < 3; kx++) {
                                const pixelIndex = ((y + ky - 1) * width + (x + kx - 1)) * 4;
                                const weight = kernel[ky][kx];
                                r += data[pixelIndex] * weight;
                                g += data[pixelIndex + 1] * weight;
                                b += data[pixelIndex + 2] * weight;
                            }
                        }
                        outputData[i] = r; outputData[i + 1] = g; outputData[i + 2] = b;
                    }
                }
                ctx.putImageData(new ImageData(outputData, width, height), 0, 0);
                showLoading(false);
            }, 50);
        }
        
        function applyBilateralFilter() {
            if (!originalImageData) return;
            saveState();
            showLoading(true, 'Aplicando Polimento HD...');
            setTimeout(() => {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const { data, width, height } = imageData;
                const outputData = new Uint8ClampedArray(data);
                const sigmaSpace = 3; // Raio do filtro espacial
                const sigmaColor = 50; // Influência da cor

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        if (data[i + 3] === 0) continue;

                        let r_sum = 0, g_sum = 0, b_sum = 0, weight_sum = 0;
                        const r_center = data[i], g_center = data[i+1], b_center = data[i+2];

                        for (let ky = -sigmaSpace; ky <= sigmaSpace; ky++) {
                            for (let kx = -sigmaSpace; kx <= sigmaSpace; kx++) {
                                const ny = y + ky;
                                const nx = x + kx;

                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const ni = (ny * width + nx) * 4;
                                    if (data[ni + 3] === 0) continue;

                                    const r_n = data[ni], g_n = data[ni+1], b_n = data[ni+2];
                                    
                                    const spaceDist = -(kx*kx + ky*ky) / (2 * sigmaSpace * sigmaSpace);
                                    const colorDist = -(Math.pow(r_center - r_n, 2) + Math.pow(g_center - g_n, 2) + Math.pow(b_center - b_n, 2)) / (2 * sigmaColor * sigmaColor);

                                    const weight = Math.exp(spaceDist + colorDist);
                                    
                                    r_sum += r_n * weight;
                                    g_sum += g_n * weight;
                                    b_sum += b_n * weight;
                                    weight_sum += weight;
                                }
                            }
                        }
                        outputData[i] = r_sum / weight_sum;
                        outputData[i+1] = g_sum / weight_sum;
                        outputData[i+2] = b_sum / weight_sum;
                    }
                }
                ctx.putImageData(new ImageData(outputData, width, height), 0, 0);
                showLoading(false);
            }, 50);
        }
        
        function applyBrightnessContrast() {
            if (!originalImageData) return;
            saveState();
            showLoading(true, 'Aplicando ajustes...');
            setTimeout(() => {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const brightness = parseInt(brightnessInput.value);
                const contrast = parseInt(contrastInput.value);
                const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));

                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] === 0) continue;
                    data[i] = factor * (data[i] + brightness - 128) + 128;
                    data[i + 1] = factor * (data[i + 1] + brightness - 128) + 128;
                    data[i + 2] = factor * (data[i + 2] + brightness - 128) + 128;
                }
                ctx.putImageData(imageData, 0, 0);
                showLoading(false);
            }, 50);
        }

        function getSharpenKernel() { return [[0, -1, 0], [-1, 5, -1], [0, -1, 0]]; }
        function getSmoothKernel() { const v = 1/9; return [[v,v,v],[v,v,v],[v,v,v]]; }

        function analyzeAndRemoveBackground() {
            ctx.putImageData(originalImageData, 0, 0); 
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            floodFillFromEdges(imageData, calculateAutoTolerance(imageData));
            ctx.putImageData(imageData, 0, 0);
        }

        function polishEdges() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const { data, width, height } = imageData;
            const newData = new Uint8ClampedArray(data);
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const i = (y * width + x) * 4;
                    if (data[i + 3] === 0) continue;
                    let isEdge = false;
                    const neighbors = [(y*width+(x-1))*4, (y*width+(x+1))*4, ((y-1)*width+x)*4, ((y+1)*width+x)*4];
                    for (const n_i of neighbors) { if (data[n_i + 3] === 0) { isEdge = true; break; } }
                    if (isEdge) {
                        let r = data[i], g = data[i+1], b = data[i+2], count = 1;
                        for (const n_i of neighbors) {
                            if (data[n_i + 3] > 0) { r += data[n_i]; g += data[n_i + 1]; b += data[n_i + 2]; count++; }
                        }
                        newData[i] = r / count; newData[i + 1] = g / count; newData[i + 2] = b / count;
                    }
                }
            }
            ctx.putImageData(new ImageData(newData, width, height), 0, 0);
        }
        
        function floodFillFromEdges(imageData, tolerance) {
            const { width, height } = imageData;
            for(let x = 0; x < width; x+=10) { floodFill(imageData, x, 0, tolerance); floodFill(imageData, x, height - 1, tolerance); }
            for(let y = 0; y < height; y+=10) { floodFill(imageData, 0, y, tolerance); floodFill(imageData, width - 1, y, tolerance); }
        }

        function floodFill(imageData, startX, startY, tolerance) {
            const { data, width, height } = imageData;
            const stack = [[startX, startY]];
            const startNode = (startY * width + startX) * 4;
            const targetColor = [data[startNode], data[startNode + 1], data[startNode + 2]];
            if (data[startNode + 3] === 0) return;
            const processed = new Set();
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;
                if (x < 0 || x >= width || y < 0 || y >= height || processed.has(key)) continue;
                processed.add(key);
                const currentNode = (y * width + x) * 4;
                if (colorDistance(targetColor, [data[currentNode], data[currentNode+1], data[currentNode+2]]) <= tolerance) {
                    data[currentNode + 3] = 0;
                    stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
                }
            }
        }

        // --- FUNÇÕES AUXILIARES GERAIS ---
        function showLoading(show, text = '') { loadingText.textContent = text; loadingOverlay.style.display = show ? 'flex' : 'none'; }
        function getPixel(data, width, x, y) { const i = (y * width + x) * 4; return [data[i], data[i+1], data[i+2]]; }
        function colorDistance(c1, c2) { return Math.sqrt(Math.pow(c1[0] - c2[0], 2) + Math.pow(c1[1] - c2[1], 2) + Math.pow(c1[2] - c2[2], 2)); }
        function calculateAutoTolerance(imageData) {
            const { data, width, height } = imageData;
            const edgeColors = [];
            for (let i = 0; i < width; i+=5) { edgeColors.push(getPixel(data, width, i, 0)); edgeColors.push(getPixel(data, width, i, height - 1)); }
            for (let i = 0; i < height; i+=5) { edgeColors.push(getPixel(data, width, 0, i)); edgeColors.push(getPixel(data, width, width - 1, i)); }
            const cornerColor = getPixel(data, width, 0, 0);
            let totalDist = 0;
            edgeColors.forEach(c => totalDist += colorDistance(c, cornerColor));
            return (totalDist / edgeColors.length) + 25;
        }

        downloadBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'imagem-final.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        });

    </script>
</body>
</html>
